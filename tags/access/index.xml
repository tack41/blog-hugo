<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>access on tack41&#39;s blog</title>
    <link>https://blog.tack41.net/tags/access/</link>
    <description>Recent content in access on tack41&#39;s blog</description>
    <image>
      <url>https://blog.tack41.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.tack41.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Sat, 30 Jul 2022 00:00:00 +0900</lastBuildDate><atom:link href="https://blog.tack41.net/tags/access/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Accessでグラフ</title>
      <link>https://blog.tack41.net/posts/2022/07/30_02/</link>
      <pubDate>Sat, 30 Jul 2022 00:00:00 +0900</pubDate>
      
      <guid>https://blog.tack41.net/posts/2022/07/30_02/</guid>
      <description>TL;DR AccessのグラフはModernとClassicの2種類。細かい要件は無くて手っ取り早くきれいなグラフを作るならModern、調整が必要な場合はClassic。(Classicならどんなグラフも可能とは言ってない) 経緯 Accessでグラフを作ることになり調査。最新のMS365のAccessでは、ModernとClassicの2つがあることが分かった。
Modernは、今どきのおしゃれな感じのグラフがパッとできる。が、マーカーのサイズを調整したりとか、凡例の位置を微調整したりとか、細かいところができない。
一方Classicは、見た目は古臭くて野暮ったいが、かなり細かい調整ができる。
MicrosoftとしてはModernを売っていきたいのだろが、Classic出ないとできないことがまだ結構ある印象。それでも長期的にはModernに統一される可能性はあるので、Modernで十分な場合は採用し、そうでない場合のみClassicとするのがよいだろう。</description>
    </item>
    
    <item>
      <title>Accessの通貨型にはSystem.Decimal</title>
      <link>https://blog.tack41.net/posts/2021/07/21_01/</link>
      <pubDate>Wed, 21 Jul 2021 00:00:00 +0900</pubDate>
      
      <guid>https://blog.tack41.net/posts/2021/07/21_01/</guid>
      <description>TL;DR .Net FrameworkからAccessの通貨型の列に値を設定する場合は、System.Decimal型を利用する。
経緯 伝票番号が11桁の数値となるシステムにて、値をSystem.Int64型に格納していた。最終的にAccessのテーブルに格納する必要があり、こちらは通貨型で整数部11桁で定義していた。
OleDb経由でParameterを利用して(SQLにべた書きせずにobject型の変数として渡す)INSERTしたところ、何のエラーも吐かずにこけた。
どうも、System.Int64(=long)が渡されるとAccess側ではLong型(-2,147,483,648 ～ 2,147,483,647)に変換しようとするらしい。ただ、該当の列に「1L」(System.Int64型)を与えるとこけるが、「1」(System.Int32)ではこけないので、値そのものではなく型の違いによるエラーなのだと思われる。DEBUG実行してもエラーをはかずにこけるので切り分けに時間がかかった&amp;hellip;
相手が通貨型11桁なのでそれに合わせてよしなに変換してくれるものと思っていたが甘かった。が、前回同じコードを実行した際にはエラーは起きなかったはずなのだが&amp;hellip; 仕様が変わったのか?
まぁ、特にAccessのような(レガシーな?)システムとの接続の際には、自動変換には期待せずこちらで必要な型が分かる場合は指定したほうが無難だと理解した。</description>
    </item>
    
    <item>
      <title>Accessでフォーム起動時に該当列が存在しないエラーの原因究明</title>
      <link>https://blog.tack41.net/posts/2020/09/05_01/</link>
      <pubDate>Sat, 05 Sep 2020 00:00:00 +0900</pubDate>
      
      <guid>https://blog.tack41.net/posts/2020/09/05_01/</guid>
      <description>Access であるフォームを起動時に、特定の列が存在しない旨のエラーが表示された。その原因究明について。
該当フォームのレコードソースを見るとクエリが指定されており、エラーメッセージに表示された列が存在しないことを確認。ただ、どこから参照されているかがわからない。
該当フォームはマクロで起動されていたのでマクロを調べてみたが、フォームを起動する処理のみでおかしなところはない。 該当フォームの全てのコントロールのコントロールソースのプロパティを調べてみたが、エラーとなっている項目を参照している箇所はない。 VBAマクロにて該当フォーム内の全プロシージャを調べてみたが、やはり参照箇所はない。
最終的に、フォームの並び替えのプロパティで参照されていた。 かなり時間がかかってしまったが、次回同じようなことが起こった際には、ariawaseのようなツールでVBAをエクスポートしたあと、grepするほうが早くて確実だと思う。</description>
    </item>
    
    <item>
      <title>mdbファイルが破損している場合</title>
      <link>https://blog.tack41.net/posts/2020/07/29_01/</link>
      <pubDate>Wed, 29 Jul 2020 00:00:00 +0900</pubDate>
      
      <guid>https://blog.tack41.net/posts/2020/07/29_01/</guid>
      <description>mdbファイルが破損している場合、最初のクエリ実行時にOleDbExceptionが発生します。 これをキャッチすれば破損を検知するロジックはとりあえず書けます。</description>
    </item>
    
    <item>
      <title>Accessはできることが多すぎる</title>
      <link>https://blog.tack41.net/posts/2020/06/28_01/</link>
      <pubDate>Sun, 28 Jun 2020 00:00:00 +0900</pubDate>
      
      <guid>https://blog.tack41.net/posts/2020/06/28_01/</guid>
      <description>過去に開発された内製アプリをC#+RDBMSに置き換えていて思うこと。
kintoneやPowerAppsのようなローコード、ノーコードと言われる分野のアプリで置き換えようとすると機能が足りず、ガッカリして断念している。 ふと思うのは、むしろAccessが高機能すぎるのではないかということ。特にVBAはやろうと思えばなんでもできてしまう。会社の前の基幹アプリはAccess VBAでできていたし。
Accessが目指すべきなのは、クエリ、マクロ、フォームの組み合わせでできることに特化すべきで、それ以上のことは別のやり方でやってください、とすべきだったのではと思う。VBAは禁止。クエリもGUIで組み立てられるレベルまで、サブクエリは禁止、くらいでちょうど良い。
WordやExcelのVBAは、普通に作る分にはUI,データソース共に限られるので問題にならないが、AccessはなまじDBMSとしてテーブル、SQLをサポートしているので複雑なことまでやろうとしてしまう。グラフもそれなりに書けてしまうし。
他の言語がここ十何年で目覚ましい進歩を遂げて入り一方でVBAがここ何年もほとんど進化していないのは、できることが多すぎてそれらを維持したまま進化させるのが難しいという一面もあると思う。メインの利用者が非開発者でそのような進歩を望んでいないことも大きいと思うが。
最新の言語を書いた後にVBAのプアな機能を使ってコードを書くのはとても辛い&amp;hellip; Visual Studio Tools for OfficeもAccessはサポートしてないし。
ローコード、ノーコードアプリはスプレッドシートをデータソースとすることが多いので、AccessはExcelのみをデータソースとしてサポートする、くらいで良いと思うが、それってPowerBIだよねという話で、Accessはもはや不要な製品だと思う。
Accessの値段でAccessと同等の機能を持つ製品はなく、(自分も含めて)影響は大きいが、大規模な時代遅れなAccessのVBAの保守を任される開発者も、時代遅れなVBAを進化させることができずに細々とサポートするMicrosoftの開発者も不幸な今の状況を考えると、Accessは終了すべきと思う。長めの期間をとって移行のロードマップを示す必要はあるが。10年後にVBAバリバリのAccessアプリが残っている未来を想像したくない。</description>
    </item>
    
    <item>
      <title>Access 2003からMariaDBに移行</title>
      <link>https://blog.tack41.net/posts/2018/08/19_01/</link>
      <pubDate>Sun, 19 Aug 2018 00:00:00 +0900</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/08/19_01/</guid>
      <description>内製のAccess 2003アプリを、DB部分はMariaDBに移行している。 フロントは.Net(C#)
ツールを使って工数を削減できないかと模索したが、以下のような正攻法で攻めるしかないと言う結論に達した。
Access側のテーブルにて、極力Not Null制約を適用する&amp;hellip; 後述のデータ移行クエリ実行の際、NullがあるとINSERT SELECT 文がこけるため、Nullの場合とそうで無い場合で別クエリを実行する必要が出てくるため。
文字列型は、NULL=空文字と考えて問題ない場合がほとんどと想定されるので、以下の手順を機械的に実行する。
文字列でない場合はNULLを置き換えるべき値が自明でない場合も多いので、一旦NULL値固定で移行し、列ごとに個別で移行(UPDATE DEST.COL=SRC.COL WHERE SRC.COL IS NOT NULL) 対象列の空文字を許可する。 該当列を更新する部分にてNULLの場合は空文字に置き換える処理を追加 画面のフォームがデータと連結していてSQLではなくDoCmdで処理している場合、後付でSQLを組み込むと競合エラーが面倒なので、単純にフォームの値をNz関数でNullを置換してやれば良い ウィザードに従って作成した画面などで、データ更新処理を明示的に記載されていない場合は、フォームの追加・更新前処理イベントにてNz関数を適用する UPDATE文で該当列のNULLを空文字に置換 該当列にNOT NULL制約を適用。 MariaDB側に、同一レイアウトのテーブルを新規作成。参照制約も実装。 MariaDBのODBCドライバをインストールし、対象のMariaDBをODBC登録。 AccessのリンクテーブルとしてMariaDBのテーブルを登録 AccessのテーブルからMariaDBのテーブルにデータを流し込む(INSERT SELECT)クエリを作成、初回の移行を行う。
参照整合性制約から、移行可能な順番がはっきりする。 MariaDBのデータに対してアクセスするフロントプログラムを作成する。 移行後のテーブルレイアウトそのものでプログラムの動作検証が可能。 フロントプログラムの作成が完了したら、MariaDBの全データをTruncateしてデータの本番移行を行う。 データ移行の逆順で実行しても参照整合性制約からデータを削除できない場合がある。素直に参照整合性制約を一時削除し、データの削除完了後に再度作成する。 テーブル名や列名にスペースやマルチバイト文字が入ってて命名規則を満たしていない、明らかに数量データなのに文字列型になっている&amp;hellip;といった問題はこれ以降にじっくりリファクタリングしていく。上記の手順とリファクタリングを同時に行うのはリスクが大きい。</description>
    </item>
    
    <item>
      <title>AccessにOleDbアクセス時、日付型のパラメータを使用する場合は型を明示する必要あり</title>
      <link>https://blog.tack41.net/posts/2018/02/20_01/</link>
      <pubDate>Tue, 20 Feb 2018 00:00:00 +0900</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/02/20_01/</guid>
      <description>はまった&amp;hellip; Accessのときのみ発生。
Parameterを使う際、通常、設定した値の型からよきにはからって処理してくれるが、AccessでDateTime、特に時刻部分が設定されている場合ではエラーとなる。
http://yan-note.blogspot.jp/2008/08/systemdatacommondbparameteraccessdate.html</description>
    </item>
    
    <item>
      <title>AccessでのYes/No型を外部結合してGroupByすると「カレントレコードがありません」</title>
      <link>https://blog.tack41.net/posts/2018/01/21_01/</link>
      <pubDate>Sun, 21 Jan 2018 00:00:00 +0900</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/01/21_01/</guid>
      <description>タイトルの通り。
Accessで、OLEDB経由でもAccessで直接クエリをたたいても「カレントレコードがありません」と表示されるエラーに遭遇し、SQLを切り分けたところ、Yes/No型のフィールドが原因と判明。 ググってみると、Yes/No型を外部結合してGroupByすると、Nullが発生した場合に処理できず、このようなエラーが出るらしい。
https://www.pcreview.co.uk/threads/no-current-record-error-in-group-by-query-with-outer-joins-solution.2126293/
対処法は、リンク先にある通り、SELECT、GROUP BYの双方をNzでNullの場合の値を指定すること。
OLEDB接続の場合はNz関数が利用できないので、IIfとIsNullを組み合わせる。
Access嫌だ&amp;hellip;</description>
    </item>
    
    <item>
      <title>テーブル定義の移行でよく使う方法</title>
      <link>https://blog.tack41.net/posts/2017/11/30_01/</link>
      <pubDate>Thu, 30 Nov 2017 10:51:34 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2017/11/30_01/</guid>
      <description>社内DBを試行錯誤しているため、DB間データ移行の前段としてテーブル定義をコピーしたいことがある。 大抵のDBでは無料でもツールが充実しており、ODBCライブラリを入れればよっぽど問題ないと思うのだが&amp;hellip;
MySQL &amp;hellip; Workbench Oracle &amp;hellip; SQL Developer SQL Server &amp;hellip; SQL Server Management Studio(SSMS) Windows 10 Pro 64bitで、SSMSからOracleにアクセスしようとしたところ、どうにもエラーでうまく行かない。64bitのInstant Client + ODBCをインストールし、OSのODBC管理ツールでテスト接続は成功しているのだが&amp;hellip;
で、こういう時はAccessでODBC経由でリンクを貼る分にはまず失敗しない。この状態でテーブルをAccessにテーブル定義のみコピーし、そのAccessのテーブルをSSMSでインポートするとうまくいく。</description>
    </item>
    
  </channel>
</rss>
