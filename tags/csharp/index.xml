<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>csharp on tack41&#39;s blog</title>
    <link>https://blog.tack41.net/tags/csharp/</link>
    <description>Recent content in csharp on tack41&#39;s blog</description>
    <image>
      <url>https://blog.tack41.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</url>
      <link>https://blog.tack41.net/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 09 Oct 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://blog.tack41.net/tags/csharp/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Bootstrapper().Run() 実行時にFileNotFoundException</title>
      <link>https://blog.tack41.net/posts/2018/10/09_01/</link>
      <pubDate>Tue, 09 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/10/09_01/</guid>
      <description>WPFでPrsimを習得しようと日々格闘中です。
ふとしたタイミングで、Bootstrapper().Run()実行時に
&amp;#34;ファイルまたはアセンブリ &amp;#39;System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&amp;#39;、 またはその依存関係の 1 つが読み込めませんでした。指定されたファイルが見つかりません。 &amp;#34;:&amp;#34;System.Runtime, Version=4.1.2.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a&amp;#34; なるエラーが表示されて進まなくなってしまいました。 シンプルなShellのみ起動するように修正してもダメ。NuGetですべてのライブラリを一旦アンインストールし、最小限のみとして前に正常に起動した状態に戻してもダメ。
どうやら、app.configとターゲットバージョンにより発生(自分のプロジェクトでは4.7.2)するらしい。
[https://github.com/dotnet/standard/issues/567:title]
Workaroundsにあるようにapp.configのdependentAssemblyタグをすべて削除し、ターゲットバージョンを一旦4.0にして再度4.7.2に戻したところエラーが消えて動作するようになった&amp;hellip;</description>
    </item>
    
    <item>
      <title>WPFのMVVMについて考える</title>
      <link>https://blog.tack41.net/posts/2018/10/01_01/</link>
      <pubDate>Mon, 01 Oct 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/10/01_01/</guid>
      <description>最近、Windows FormをやめてWPFのプログラムを書き始めている。
WPFは正直必要となる知識レベルが高く難しいというイメージで手が付けにくかった。今もそうだが。 何が難しいかといえば、MVVMの考え方をどこまで徹底するかに尽きるのではないかと思う。
MVVMについてまだまだ分からないことも多いが、今の認識をまとめる。
 MVVMは、ModelとViewの間にViewModelという層を挟み、ModelとViewの依存関係を疎にするモデル WPFの場合、ViewとViewModelの間でデータを複雑なコード不要でやりとりするBindingという機構があるので、うまく記述すればViewとViewModelの間も疎にできる そうすると、Model, ViewModelは変えずにViewだけ差し替えることも可能となる。 Windows Formの場合は、Viewの一部であるコードビハインドに処理もがっつり書いてしまうため、Viewだけ差し替えるということはできず結構な書き換えが必要となる。 Windows Formもそうだが、何も考えずに書くとどうしてもViewに処理を書いて肥大化しがち。そこで、ViewはViewModelの処理の呼び出しのみにする方が良いとされ、コードビハインドには極力コードを書かない方が良いとされる。 逆にViewModel側もViewに依存してしまうと別のViewに差し替えることができなくなるので、Viewに関するコードは書かない方が良いとされる。  MessageBoxのようなダイアログや、別のWindowを直接起動する処理すら良くないとされる。  じゃあどうするんだというと、Blendと言う部品や直接呼び出さずにInterface経由とすることで直接依存を避ける手段を取るべきとされる。これが初心者には超絶難解だと思う。     逆に、上記のようなViewを差し替える事態がそもそも考えなくて良いのであれば、今まで通りコードビハインドにコードを書いても問題はない。それでもWindows Formより洗練された部品が使えるのでメリットはある。  さしあたって、すぐに直面するのはViewModelからMessageBoxのような利用者への通知処理をどう行うか。行いたいのはMessageBoxを出すことではなく利用者にメッセージを伝えることと抽象化し、ShowMessageのようなメソッドをもつInterfaceを定義してこれを利用する形とする方法をとっている。以下のページが参考になった。
[http://sourcechord.hatenablog.com/entry/2016/01/23/170753:embed:cite]
このパターンは、コンストラクタに引き渡す処理に気をつければViewModelからのViewの呼び出しが簡単にできるため、よく使っています。</description>
    </item>
    
    <item>
      <title>ClosedXMLでWindows7だけレイアウトが崩れる</title>
      <link>https://blog.tack41.net/posts/2018/09/13_01/</link>
      <pubDate>Thu, 13 Sep 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/09/13_01/</guid>
      <description>アホな話です。
ClosedXMLで、一部コードでうっかり以下のようなコード書いてました。
 using (IXLWorkbook targetBook = new XLWorkbook(filePath))  {  using (IXLWorksheet targetSheet = targetBook.Worksheet(1))  {   }   targetBook.Save();  } usingの入れ子です。 普通、入れ子になるような階層があれば一番上位のクラスが下位のDispose呼んでくれるっと思いますよね〜。 でも、このときはusing句覚えたてで、とにかく使いたかったんです、using入れ子かっけ〜って思ってたんです&amp;hellip;
症状としては、Windows 7の場合のみシートのフォーマットが崩れます。なぜかWindows 10は大丈夫。OSによって症状が違う理由は不明。 sourceを見ると、XLWorksheetのDisposeでrange情報をクリアしてるっぽいから、そこで情報が消えて、そのまま保存すればそりゃレイアウトは崩れるな〜と。
追記) どうも、最新の0.93.1で発生し、0.92.0では発生しなかったようだ。ライブラリのバージョンアップした途端に大量に問い合わせが&amp;hellip;</description>
    </item>
    
    <item>
      <title>Microsoft Report使用時のビルド時の警告</title>
      <link>https://blog.tack41.net/posts/2018/07/30_02/</link>
      <pubDate>Mon, 30 Jul 2018 01:00:00 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/07/30_02/</guid>
      <description>Visual Studio 2017にてMicrosoft Reportを使用するために、Nugetで[Microsoft Rdlc Report Designer for Visual Studio]をインストールすると、ビルド時に「同じ依存アセンブリの異なるバージョン間での競合が見つかりました。」と警告が表示される。実行自体は問題なくできる。
[https://qiita.com/hahifu/items/8dba20cd06fb0c3a9fa7:embed:cite] を参考に出力の詳細レベルを上げて確認すると、ReportのアセンブリがSQLServer.Typesの12.0.0に依存している一方で、NugetでReportインストール時に一緒にインストールされるSQLServer.Typesは14.0.0であるためのようだ&amp;hellip;
依存関係の解消方法が思い付かず、また動作には影響はないため以下のサイトを参考に
[https://docs.microsoft.com/ja-jp/dotnet/framework/configure-apps/how-to-enable-and-disable-automatic-binding-redirection:title] 自動バインド リダイレクトを有効化したところ、警告は出なくなった。</description>
    </item>
    
    <item>
      <title>ClickOnceでハマる</title>
      <link>https://blog.tack41.net/posts/2018/07/30_01/</link>
      <pubDate>Mon, 30 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/07/30_01/</guid>
      <description>C#で開発したクライアントアプリケーションをClickOnceで配布する際にハマった2点
Windows10へのインストール イントラのファイルサーバに置いてある証明書が設定されていないClickOnceをWindows 10で実行すると、「コンピューターにセキュリティ上の問題を発生させるため、管理者がこのアプリケーションをブロックしました。&amp;hellip;」と表示され、[閉じる]ボタンしか表示されないために、インストールができない。 Windows 7では普通にインストールできる。
[https://answers.microsoft.com/ja-jp/windows/forum/apps_windows_10-winapps-appscat_tools/%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC/45f6621c-35ca-4395-bdd4-685705e9fae0:embed:cite] にあるレジストリの[LocaIntranet]の値をEnabledにする必要があった。 設定変更は直ちに反映される(OS再起動は不要)
関連アセンブリの添付 上記をクリアしたうえでClickOnceを公開し、クライアントで実行すると以下のエラーが表示される。
このアプリケーションをインストールまたは実行できません。このアプリケーションでは、まずグローバルアセンブリキャッシュ(GAC)にアセンブリ Microsoft.**** バージョン *** をインストールする必要があります。 ****にはVisualStudio関連のアセンブリ各種が出力される。Visual Studio 2017 Express Desktopの時は発生しなかったのだが、2017 Professionalにしたら発生した。 どうも必要なアセンブリ(.dll)を添付できていないようで、事例は異なるが、
[http://thinkami.hatenablog.com/entry/2014/09/09/062440:embed:cite] にあるように公開設定で全てのアセンブリを「必須コンポーネント(自動)」→「含む」に変更すると解消した。</description>
    </item>
    
    <item>
      <title>実行順序に依存する複数LINQ実行時の遅延評価による副作用</title>
      <link>https://blog.tack41.net/posts/2018/07/19_01/</link>
      <pubDate>Thu, 19 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/07/19_01/</guid>
      <description>例えば、LINQ1にて元データよりデータを抽出し、これをデータセット1とする。 次に、LINQ2にて、元データからデータセット1を除いたデータセットに対して抽出し、これをデータセット2とする。 これをLINQ3にて、元データからデータセット1とデータセット2を除いたデータセットに対して抽出し、これをデータ・セット3とする。 &amp;hellip;.
上記のような処理を1メソッドで行う。 後続のLINQで除外するために、除外するためのデータセットを例えばListとして保持する。
LINQ2はLINQ1の結果が決まらないと決まらない。LINQ3はLINQ2, LINQ1の結果が決まらないと決まらない。だが、後続のLINQに対して結果を伝えるのは(LINQとは無関係の)Listオブジェクト。
このような場合に、上記LINQを順番にコードで記載したとしても、除外Listの値は後続に伝わらない(ことがある?)。おそらく、プログラムの動作として最初にLINQ3の結果を参照した場合にLINQ1,LINQ2の結果を行ってから、という動きはしてくれず、結果、空の除外Listに対してLINQ3を実行してしまっているためと思われる。
遅延されるのが問題なので、LINQの実行結果 IEnumerable型のオブジェクトに対してToList()を実行してやれば即時に確定してこのような副作用は発生しなくなる。遅延評価のメリットは当然なくなるが。</description>
    </item>
    
    <item>
      <title>C#でExcelのバージョンに依存しないCOM経由での操作</title>
      <link>https://blog.tack41.net/posts/2018/07/04_01/</link>
      <pubDate>Wed, 04 Jul 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/07/04_01/</guid>
      <description>C#での社内プログラムでExcelを操作する際、大部分はClosedXMLを利用しているのだが、ActiveXを使用しているなどでうまく動作しない場合にはCOM経由で操作している。
Visual Studioで参照ツリーにExcelのCOM参照を追加するのだが、その時点でPCにインストールされているOfficeのバージョンに対応したCOMを追加する形になる。
ビルド時に参照ツリーにあるCOMを参照するため、参照追加時のPCとビルド時のPCでインストールされているOfficeのバージョンが異なると、ビルド時に警告、またはエラーとなる。
参照追加時には2013、ビルド時に2016だったためにビルド時に警告が出て、そのまま実行すると該当箇所でRuntime Errorでコケる事象が発生した。 社内には、今後2013, 2016が混在する予定のため、どちらかだけしか対応できないとなると困るので、対応方法を調査した。
参照ツリーに追加して開発する形式を事前バインディング、実行時にCOMの名前から該当のCOMを参照する形式を遅延(動的)バインディングというらしい。
 事前バインディング  Visual StudioでCOMオブジェクトの仕様を把握しているため、補完が効いて開発効率が高い 型情報なども取得済みでコンパイルするため、実行速度は遅延バインディングと比較して速い 使用するOfficeのバージョンを指定する必要がある。   遅延バインディング  使用するOfficeのバージョンを指定する必要がない Visual Studioでの補完は効かず、各オブジェクト、メソッドの情報を調べながら呼び出す必要がある。大変。 実行時に型チェックを行うため、遅い。実行時エラーが出る可能性も。    遅延バインディングは、各メソッドをInvokeMemberで引数を調査しながら呼び出す必要があり、とても大変。以下のサイトにこの大変さをWrapするコードが公開されていた。
[https://zenmai.wordpress.com/2011/06/24/excel%E3%81%AE%E5%8F%82%E7%85%A7%E3%82%92%E8%BF%BD%E5%8A%A0%E3%81%9B%E3%81%9A%E3%81%ABexcel%E3%82%92%E4%BD%BF%E3%81%86c/:embed:cite] とても素晴らしいのでぜひ利用しようと考えたのだが、(当然ながら)COMオブジェクトのすべてが実装されているわけではないので不足個所を追加実装する必要があり、結構大幅な追加が必要と思われた。
で、たどり着いたのがこちらの記事。
[https://teratail.com/questions/109579:embed:cite]
なんと、dynamicという宣言に変更するだけで、ビルド時のチェックはやめて実行時に動的に呼び出してくれるとのこと。 (COMオブジェクトの生成部分は固有の書き方への変更が必要)。素晴らしい!!
実際にdyamicに変更したところ、WorkbookオブジェクトへのReleaseComObject呼び出し時にエラーが発生。
[http://hiro-syumi.ldblog.jp/archives/36511362.html:embed:cite] こちらの記事を参照させてもらってエラー箇所のみobject型へのキャスト処理を追加したところ、問題なく動作するようになった。
このdynamicの利用だが、最初からこれを前提に行うと上記の通りVisualStudioによるサポートが効かないので開発効率はかなり落ちると思われる。今回のようにCOM参照を追加して事前バインディングで実装したうえで、dynamicに書き換えるという形が効率が良いと感じた。</description>
    </item>
    
    <item>
      <title>COM経由でのExcel操作は地獄?</title>
      <link>https://blog.tack41.net/posts/2018/02/24_01/</link>
      <pubDate>Sat, 24 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/02/24_01/</guid>
      <description>VBAでExcelを操作するプログラムをC#に移行。 印刷に使用するActiveXオブジェクトを含む雛形ファイルを対象とするため、Managedな操作をするClosedXMLやNPOIではうまく動作せず、Interop.Excel経由で行った。
ClosedXML等と比較して圧倒的に動作が遅いのは当然として、シートをある程度(10枚以上?)コピーするとtmpファイルを書き込めない旨のエラーが発生する。 タイミングは実施するたびに違い、運が良ければエラーが発生しないこともある。
同様のエラーを探したが、結論としてはエラー時にリトライする処理を追加するくらいしかないらしい&amp;hellip;
[https://answers.microsoft.com/ja-jp/msoffice/forum/msoffice_excel-mso_winother-mso_2010/vba%E3%81%A7%E3%82%B7%E3%83%BC%E3%83%88%E3%82%B3/b8b84a3e-d1f8-48a5-8623-04023c8510e8:embed:cite]
こういった対処方法は、仕方ないとしても凹みますね。 機会があればネックとなっているActiveXオブジェクトをManagedな操作で置き換えていきたい。</description>
    </item>
    
    <item>
      <title>AccessにOleDbアクセス時、日付型のパラメータを使用する場合は型を明示する必要あり</title>
      <link>https://blog.tack41.net/posts/2018/02/20_01/</link>
      <pubDate>Tue, 20 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/02/20_01/</guid>
      <description>はまった&amp;hellip; Accessのときのみ発生。
Parameterを使う際、通常、設定した値の型からよきにはからって処理してくれるが、AccessでDateTime、特に時刻部分が設定されている場合ではエラーとなる。
[http://yan-note.blogspot.jp/2008/08/systemdatacommondbparameteraccessdate.html:embed:cite]</description>
    </item>
    
    <item>
      <title>C#でのDbTransaction.Rollback</title>
      <link>https://blog.tack41.net/posts/2018/02/02_01/</link>
      <pubDate>Fri, 02 Feb 2018 00:00:00 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2018/02/02_01/</guid>
      <description>C#のTransactionにて、DbTransactionをusing句で使えば、Disposeの際にRollbackされるので、明示的なRollbackが不要とあったのだが、どうもそのように記載しているサイトのほうが少ないように見える。
MSDNで確認したところ、そうあるべきではるが、ベンダー依存のため前提とするのはだめらしい。
Dispose should rollback the transaction. However, the behavior of Dispose is provider specific, and should not replace calling Rollback. [https://msdn.microsoft.com/ja-jp/library/bf2cw321(v=vs.110).aspx]
SqlTransactionだけならいいかもしれないが、OleDb(Access)やMySQLも共通化している今のコードでは駄目なようだ。try catch使うしかない。
[https://msdn.microsoft.com/ja-jp/library/system.data.idbtransaction.rollback(v=vs.110).aspx:title]</description>
    </item>
    
    <item>
      <title>ClosedXMLの画像追加におけるWorksheetの取り扱いについて</title>
      <link>https://blog.tack41.net/posts/2017/11/07_01/</link>
      <pubDate>Tue, 07 Nov 2017 10:20:41 +0000</pubDate>
      
      <guid>https://blog.tack41.net/posts/2017/11/07_01/</guid>
      <description>C#でClosedXMLを使用してExcelに画像を追加する処理をしていた際、なぜかWorkbookの保存時にObjectDisposedExceptionが発生するという事態になりました。
以下のようなコードです
 using (XLWorkbook wb = new XLWorkbook(filePath))  {  IXLWorksheet ws_src = wb.Worksheet(&amp;#34;Template&amp;#34;);   using (IXLWorksheet ws = ws_src.CopyTo(&amp;#34;1&amp;#34;))  {  var image = ws.AddPicture(imagePath1);  image.MoveTo(ws.Cell(3, 3).Address);  image.Scale(.5);   image = ws.AddPicture(imagePath2);  image.MoveTo(ws.Cell(20, 3).Address);  image.Scale(2);   }   using (IXLWorksheet ws = ws_src.CopyTo(&amp;#34;2&amp;#34;))  {  var image = ws.AddPicture(imagePath3);  image.MoveTo(ws.Cell(3, 3).Address);  image.Scale(.5);  }   ws_src.</description>
    </item>
    
  </channel>
</rss>
